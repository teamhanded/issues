WordPress malware can infiltrate the server because of unattended, outdated WordPress core installations, poorly coded plugins, etc. This is some of my experience tracking down malicious code. I currently do Systems Engineering at a big web hosting company, so this is our everyday bread, unfortunately.   

Most of the times one realizes something's wrong because of a high IO wait, CPU load, memory usage or open ports. For example, in this output we see at the last line a single isolated "bash" process in sleeping mode (rogue PIDs use names such as "exim", "bash", "qmail" to disguise themselves using important-looking names)

```
# ps afxww | grep bash
15703 pts/0    Ss     0:00  |   \_ -bash
19826 pts/0    S      0:00  |       \_ -bash
19827 pts/0    S      0:00  |       |   \_ tee -a /root/.bash_history
19828 pts/0    S      0:00  |       |   \_ logger -t bash[root-15703] 10.xx.xx.xx 39340 10.xx.xx.xx 22
20811 pts/0    S+     0:00  |       \_ grep bash
18930 pts/1    Ss+    0:00      \_ -bash
20694 pts/1    S+     0:00          \_ -bash
20695 pts/1    S+     0:00              \_ tee -a /root/.bash_history
20696 pts/1    S+     0:00              \_ logger -t bash[root-18930] 10.xx.xx.xx 41574 10.xx.xx.xx 22
19188 ?        Ss     0:00 bash
```

For example the last PID in sleeping state and running headless is a Perl script, as seen here (this is the Perl binary, of course, but we can infer the process is a Perl invocation with either in-line code or a script filename as parameter from a .php script, for example).

```
~ # file /proc/31670/exe
/proc/19188/exe: symbolic link to `/usr/bin/perl5.18.2
```

The /proc pseudo-filesystem is your friend here. Some useful commands to run:

```
~ # cat /proc/[PID]/cmdline // Useful for seeing the actual invocation that spawned that process
 
~ # cat /proc/[PID]/cwd // Symbolic link to the folder being used by the process
 
~ # cat /proc/[PID]/maps // See allocated memory for the system and user libraries used by the process
 
~ # cd /proc/[PID]/fd // File descriptors used by the process. Alternative command: lsof
 
~ # cat /proc/[PID]/environ // Environmental data. Very useful for getting a hang of what's going on. Includes IPs, BASH variables, etc.
```

Important: sometimes you won't be able to see much information on /proc regarding a process. If it's a Perl script, it's most likely due to being run from either a PHP shell, or it can be obfuscated and evaluated via the eval() function, or sometimes it is run in-line from a privileged shell, instead of from a script. This will make files like /proc/[PID]/environ useless.

While trying to see the PIDs working directory, we see the user hosting the process (1802208.1951401).

```
~ # lsof -p 29770 | grep cwd
bash    29770 1802208.1951401  cwd    DIR                8,1     4096          2 /
```

Now that we've pinpointed the affected user, we have to search the account for the bad code(1). In this example, the aforementioned website has an infected file, namely /home/1802208.1951401/htdocs/wp-includes/nav-menu.php .

Here you have a sample of one of the most common infection routines: use of the base64_decode PHP function. In this case, when decoded, the obfuscated Base64 code points to a certain URL. In this case, it was an opening for a PHP shell to download.

```
<?php
 
function decrypt_url($encrypted_url)
{
    $encrypted_url = base64_decode($encrypted_url);
    $url = 'a3d3czksLDIyMy0yOzQtMjsyLTIzNCxhb2xkLDxwYm5wdm1kJXZ3blxwbHZxYGY+NjsxMDE5MjI1MTo6OzkxMzYz';
    for ($i = 0; $i < strlen($encrypted_url); $i++)
    {
        $url .= chr(ord($encrypted_url[$i]) ^ 3);
    }
    echo $url;
}
echo decrypt_url('a3d3czksLDIyMy0yOzQtMjsyLTIzNCxhb2xkLDxwYm5wdm1kJXZ3blxwbHZxYGY+NjsxMDE5MjI1MTo6OzkxMzYz');
?>
```

And here is the output of the function:

```
a3d3czksLDIyMy0yOzQtMjsyLTIzNCxhb2xkLDxwYm5wdm1kJXZ3blxwbHZxYGY+NjsxMDE5MjI1MTo6OzkxMzYz
http://110.187.181.107/blog/?samsung&utm_source=58232:1162998:2050
```

Note: if you want to be thorough, run the IPs or domains you've discovered through WHOIS database and also use the *dig*  command to see its DNS entries.

Now, you need to find the bad code in the files. Most of the times it will sit under these folders:

* wp-includes/
* wp-content/plugins
* wp-content/uploads
* htdocs/ folder

These are some common routines used by malware, you can grep for them

        * eval() , but bear in mind the actual function is harmless (as most of the listed ones here are), the data that passes through it is the issue and must be inspected
        * base64_encode
        * base64_decode
        * $GLOBAL
        * <body> parameter injection, usually look for cookies and JavaScript code that doesn't look right
        * Randomly upper-cased and funny-named files inside the htdocs folder, you can do it using ls -1R | less
        * Sometimes the theme is vulnerable or it just ships with malware. Some usual files to check are wp-header.php, wp-footer.php, index.php
        * Outdated plugins are also a very viable infection vector.
        * unescape() for URLDecode
        * document.write()
        * JavaScript Array[] - it usually contains obfuscated code that is concatenated on runtime.
        * ord(), str(), chr() PHP functions that has randomized cased data or out-of-place functions as parameters (usually seen in crude rotative ciphers, like Vinegere, ROT-13, etc)
        * Hexadecimal trailings. There is no sensible reason for something like \0x3d\0xbb\0xca\0xca to exist on a WordPress theme or plugin
        * Things like SDK23DBaaEWE$dSz23aS3s2ILi42bb== or anything that bugs you
        * urlencode()
        * urldecode()
        * gzip_inflate()
        * gzip_deflate() for zlib/zip binary blobs
        * stripslashes() PHP function
        * file:// php:// zip:// URL schemas

In this case, the PHP shell dynamically added backdoors into Wordpress include files inside wp-includes folder. You can try recursively changing permissions of all affected .php files (or all .php files inside a directory) to 400 (read-only); the logic behind this is that it will stop further access and spreading until you've isolated the root issue. After that, you need to stop httpd, kill the current rogue process, and start httpd again. GRanted, this is a temporary solution until either the account is restored from a backup or the original compromised files are found and dealt with.

Afterwards, you can check the process table and open processes to see if it remains.

```
~ # lsof -u 1802208.1951401
[empty]
 
~ # pgrep -u 1802208.1951401
[empty]
```

In this case, it hasn't. Congratulations, you've solved the issue! I wrote a heuristic code crawler for automating the malicious code search, you can find it here. (2)

--------------------------------------------

(1). Ideally you would run an automated search for the code, but given the creativity of some attackers when obfucating and hiding code, manual search and wits are never to be discarded and used in extreme situations.

(2) http://github.com/teamhanded/mayfly
